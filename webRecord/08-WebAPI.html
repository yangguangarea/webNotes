
---------------------------------------------
Web API 是浏览器提供的一套操作浏览器功能和页面元素的API(BOM和DOM)

MDN详细API: https://developer.mozilla.org/zh-CN/docs/Web/API

---------------------------------------------
什么是DOM
文档对象模型(Document Object Model) 是W3C组织推荐的处理可扩展标记语言(HTML
或者XML)的标准变成接口
通过这些DOM接口可以改变网页的内容、结构和样式
-----------------------
DOM树
文档---根元素<html>------元素<head>---元素<title>---文本内容
                    ┆
                    └--元素<body>---元素<a>---文本内容
                                 ┆
                                 └--元素<h1>---文本内容

文档: 一个页面就是一个文档，DOM中使用document表示
元素: 页面中的所有标签都是元素, DOM中使用element表示
节点: 网页中的所有内容都是节点(标签、属性、文本、注释等),DOM中使用node表示

-----------------------
如何获取页面元素

1.根据id获取
2.根据标签名获取
3.通过HTML5新增的方法获取
4.特殊元素获取

-----------------------
根据id获取
使用getElementById(id)方法可以获取带有ID的元素对象
找不到返回null

<div id="example">内容</div>
<script>
    var element = document.getElementById("example");
    console.dir(element);//能打印整个元素对象，更好的查看里面的属性和方法
</script>

-----------------------
根据标签名获取
使用element.getElementsByTagName('标签名') 方法可以返回带有指定标签名的对象的集合
会返回一个伪数组
得到的元素是动态的
<script>
    //获取整个document里面所有的div集合
    var elements = document.getElementsByTagName('div');
    // var elements = element.getElementsByTagName('li');
    //可以通过遍历访问伪数组中的元素
    for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
    }

    //获取id是example里边的所有的div标签集合
    var element = document.getElementById("example");
    element.getElementsByTagName('div');

</script>

-----------------------
通过HTML5新增的方法获取

<script>
    //根据类名获取元素对象集合
    var elements = document.getElementsByClassName('类名');

    //根据指定选择器返回第一个元素对象
    var element = document.querySelector('选择器');

    //比如选择第一个类名是 box 的元素
    var firstBox = document.querySelector('.box');
    //比如选择第一个id是 box 的元素
    var firstBox = document.querySelector('#box');

    //根据指定选择器返回所有符合条件的元素对象
    var elements = document.querySelectorAll('选择器');
</script>

-----------------------
获取特殊元素(body, html)
<script>
    //获取body元素
    var body = document.body;
    //获取html元素
    var html = document.documentElement;
</script>

-----------------------
事件概述

<script>
    // 事件是有三部分组成
    // 1.事件源:事件被触发的对象
    var btn = document.getElementById('btn');
    // 2.事件类型:如何触发 什么事件
    // 3.事件处理程序:通过一个函数复制的方式
    btn.onclick = function() {
        console.log("按钮被点击了");
    }
</script>

---------------------------------------------
操作元素
javascript的DOM操作可以改变网页内容、结构和样式，我们可以利用DOM操作元素来
改变元素里面的内容、属性等
-----------------------
改变元素内容

<script>
    //element.innerText
    //从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉

    //element.innerHTML
    //起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行

    //innerText 和 innerHTML 的区别
    // 1.innerText 不识别html标签 打印出之后去除空格和换行
    // 2.innerHTML 是被html标签 w3c标准 打印出之后保留空格和换行
    // 这两个属性是可读写的 可以获取元素里面的内容
</script>

例子:
<div id="biaoqian">当前内容</div>
<script>
    let d = document.getElementById('biaoqian');
    d.innerText = '<strong>内容</strong>内容';//显示内容为 <strong>内容</strong>内容
    d.innerHTML = '<strong>内容</strong>内容';//显示内容为 加粗后的字体
</script>

-----------------------
常用元素的属性操作

1. innerText、innerHTML 改变元素内容
2. src、href
3. id、alt、title

元素对象.属性名称

例子:
<button id='btn1'>图片1</button>
<button id='btn2'>图片2</button>
<img id='pic' src="http://www.baidu.com/img/flexible/logo/pc/result.png" alt="到百度首页" title="到百度首页">
<script>
    let btn1 = document.getElementById('btn1');
    let btn2 = document.getElementById('btn2');
    // let img = document.getElementById('pic');
    let img = document.querySelector('img');
    btn1.onclick = () => {
        console.log("----ffff", img);
        img.src = `http://www.baidu.com/img/flexible/logo/pc/result.png`;
        img.title = `旧百度图片`;
    }
    btn2.onclick = () => {
        img.src = `http://www.baidu.com/img/flexible/logo/pc/peak-result.png`
        img.title = `新百度图片`;
    }
</script>

-----------------------
表单元素的属性操作
利用DOM可以操作如下表单元素的属性:
type、value、checked、selected、disabled

<input type="text" name="" id="inp">
<button id='btn1'>按钮</button>
<script>
    //表单里面的值 文字内容是通过value来修改的
    let inp = document.getElementById('inp');
    inp.value = '内容';

    //禁用按钮
    let btn1 = document.getElementById('btn1');
    btn1.onclick = () => {
        btn1.disabled = true;
    }
    btn1.onclick = function() {
        //这里的this指的是事件函数的调用者
        this.disabled = true;
    }
</script>

-----------------------
样式属性操作
可以通过js修改元素的大小、颜色、位置等样式
1.element.style 行内样式操作
2.element.className 类名样式操作

注意:
1.js里面的样式采取驼峰命名法 比如 fontSize、backgroundColor
2.js修改style样式操作，产生的是行内样式，css权重比较高

<div class="block" style="width:100px; height:100px; background-color:pink;"></div>
<script>
    var block = document.querySelector('.block');
    block.onclick = () => {
        block.style.backgroundColor = "blue";//这样改完生效的是行内样式
        // block.style.cssText += "background-color:blue;";
    }
</script>

-----------------------
利用样式的显示和隐藏完成，display:none display:block
<div class="block" style="width: 100px; height: 100px; background-color: pink;"></div>
<script>
    var block = document.querySelector('.block');
    block.onclick = () => {
        block.style.display = "none";
    }
</script>

-----------------------
获得焦点onfocus 失去焦点onblur
<input type="text" name="" id="text" value="推荐内容">
<script>
    let text = document.querySelector("#text");
    text.onfocus = () => {
        text.value = "";
    }
    text.onblur = () => {
        if(text.value === "") {
            text.value = "推荐内容"
        }
    }
</script>

-----------------------
通过修改类名来改变样式
1.如果样式修改较多，可以采取操作类名方式更改元素样式
2.class因为是个保留字，因此使用className来操作元素类名属性
3.className 会直接更改元素的类名，会覆盖原先的类名
4.如果想要保留原先的类名 将原先的类名和新的类名拼接起来
<style>
    .st1 {
        width: 100px;
        height: 100px;
        background-color: pink;
    }
    .st2 {
        width: 200px;
        height: 200px;
        background-color: #ccc;
    }
</style>

<div class="st1"></div>
<script>
    let box = document.querySelector(".st1");
    box.onclick = () => {
        // box.className = "st2";
        box.className += " st2";
    }
</script>

---------------------------------------------
鼠标经过事件 onmouseover
鼠标离开事件 onmouseout
复选框是否选中状态 checked
<input type="checkbox" name="" id="" checked>

-----------------------
获取元素属性值
1.element.属性 获取属性值
2.element.getAttribute("属性");

<div class="exa" selfAttr="fuck" id="exaid"></div>
<script>
    let d = document.querySelector('.exa');
    console.log(d.selfAttr);//输出undefined
    console.log(d.id);//输出exaid
    console.log(d.getAttribute('selfAttr'));//输出fuck
    console.log(d.getAttribute('id'));//输出exaid
</script>

区别:
element.属性 获取内置属性值(元素本身自带的属性)
element.getAttribute('属性'); 主要获得自定义的属性(标准)

-----------------------
设置元素属性值
1.element.属性 = '值'
2.element.setAttribute('属性', '值')
3.element.removeAttribute('属性') 移除指定的属性
区别:
element.属性 改变元素本身属性
element.setAttribute 改变自定义的属性，也能修改预设的属性

class比较特殊，使用setAttribute的时候 key是 'class'
element.setAttribute('class', '新类名');

-----------------------
H5自定义属性
H5规定自定义属性data-开头作为属性名并复制
比如 <div data-index='1'></div>
或者使用js设置
element.setAttribute('data-index', 1);

-----------------------
获取H5自定义属性
1.兼容性获取 element.getAttribute('data-index');
2.H5新增 element.dataset.index 或者 element.dataset['index']
    如果自定义属性名有多个-链接的属性名，获取的时候采用驼峰法
<div data-num='5' data-div-name='kkk'></div>
<script>
    let ele = document.querySelector('div');
    console.log(ele.getAttribute('data-num'));//输出5
    console.log(ele.dataset.num);//输出5
    console.log(ele.getAttribute('data-div-name'));//输出kkk
    console.log(ele.dataset.divName);//输出kkk
    console.log(ele.dataset['divName']);//输出kkk
</script>
---------------------------------------------
节点概述
一般的，节点至少拥有nodeType(节点类型)、nodeName(节点名称)
和nodeValue(节点值)这三个基本属性

元素节点 nodeType 为 1
属性节点 nodeType 为 2
文本节点 nodeType 为 3 (文本节点包含文字、空格、换行等)

实际开发，节点操作主要的是元素节点

-----------------------
节点层级
利用DOM树可以把及诶单划分为不同的层级关系，常见的是父子兄层级关系

1.父级节点
node.parentNode 
    得到的是离元素最近的父级节点 
    如果指定的节点没有父节点则返回null

<div class="box">
    <div class="child"></div>
</div>
<script>
    let child = document.querySelector('.child');
    let box = child.parentNode;
    console.log(child.parentNode === document.querySelector('.box'));//输出true
</script>

-----------------------
子节点
1.parentNode.childNodes (标准)
    获取所有的节点，包含元素节点、文本节点等
2.parentNode.children (非标准)
    parentNode.children是一个只读属性，返回所有的子元素节点，其余节点不返回
    虽然children是非标准，但是得到了各个浏览器的支持
3.parentNode.firstChild
    firstChild返回第一个子节点，找不到则返回null、包含所有类型的节点
4.parentNode.lastChild
    lastChild返回最后一个子节点，找不到则返回null、包含所有类型的节点
5.parentNode.firstElementChild (IE9以上才支持)
    firstElementChild返回第一个元素子节点，找不到则返回null
6.parentNode.lastElementChild (IE9以上才支持)
    lastElementChild返回最后一个元素子节点，找不到则返回null
7.parentNode.children[0]
    获取第一个元素子节点，没有兼容性问题
8.parentNode.children[parentNode.children.length - 1]
    获取最后一个元素子节点，没有兼容性问题

<div class="box">
    <div class="child"></div>
</div>
<script>
    let box = document.querySelector('.box');
    let childs = box.childNodes;
    console.log("childs", childs);//[text, div.child, text]
    console.log(childs.length);//是三个
    //其中text是里边的换行文本节点

    //如果只想获取里边的元素节点,需要 遍历子节点的nodeType来筛选
    let eleChilds = box.children;
    console.log("eleChilds", eleChilds);
    console.log(eleChilds.length);

    console.log("firstChild", box.firstChild);//输出 text节点
    console.log("lastChild", box.lastChild);//输出 text节点
    console.log("firstElementChild", box.firstElementChild);//输出 <div class="child"></div>
    console.log("lastElementChild", box.lastElementChild);//输出 <div class="child"></div>

    console.log("firstElementChild", box.children[0]);//输出 <div class="child"></div>
    console.log("lastElementChild", box.children[box.children.length - 1]);//输出 <div class="child"></div>

</script>

-----------------------
兄弟节点
1.node.nextSibling
    nextSibling返回当前元素的下一个兄弟节点，找不到返回null。包含所有类型节点
2.node.nextElementSibling
    nextElementSibling返回当前元素的下一个元素类型兄弟节点，找不到返回null
3.node.previousElementSibling
    previousElementSibling返回当前元素的上一个元素类型兄弟节点，找不到返回null


<div class="box1"></div>
<div class="box2"></div>
<script>
    let box1 = document.querySelector('.box1');
    console.log(box1.nextSibling); //输出 text节点
    console.log(box1.nextElementSibling);//输出 <div class="box2"></div>
    console.log(box1.previousElementSibling);//输出 null
    console.log(box1.nextElementSibling.previousElementSibling);//输出 <div class="box1"></div>
</script>

-----------------------
创建节点
document.createElement('tagName')

添加节点
1.node.appendChild(child)
    将一个节点添加到指定父节点的子节点列表末尾。类似css里面的after伪元素
2.node.insertBefore(新的元素, 指定子元素)
    将一个节点添加到父节点中指定子元素的前面。类似css里面的before伪元素

<div class="box">父节点内容</div>
<script>
    let newNode = document.createElement('div');
    newNode.innerText = '子节点内容111';
    newNode.setAttribute('class', 'childBox');
    document.querySelector('.box').appendChild(newNode);
    
    let newNode2 = document.createElement('div');
    newNode2.innerText = '子节点内容222';
    document.querySelector('.box').insertBefore(newNode2, newNode);
</script>

-----------------------
删除节点
1.node.removeChild(child)
    从DOM中删除一个子节点，返回删除的节点
2.node.remove()
    移除自己

-----------------------
复制节点
node.cloneNode(isdeep)
    该方法返回调用该方法的节点的一个副本
    如果括号参数为空或者为false。则是浅拷贝，不会克隆里面的子节点
    如果括号参数为true,则是深拷贝，会复制节点本身以及里面的所有子节点
    
<div class="box">内容
    <div class="aaa"></div>
</div>
<script>
    let newNode = document.querySelector('.box').cloneNode(true);
    document.querySelector('.box').parentNode.appendChild(newNode);
</script>

---------------------------------------------
三种动态创建元素区别
1.document.write() 创建元素

<button>按钮</button>
<script>
    let btn = document.querySelector('button')
    btn.onclick = ()=> {
        document.write('<div>111</div>');
    }
</script>

2.innerHTML 创建元素

<div class="inner">123</div>
<script>
    let inner = document.querySelector(".inner");
    inner.innerHTML = '<div>456</div>'
</script>

3.document.createElement() 创建元素

区别
1.document.write() 是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘
2.innerHTML 是将内容写入某个DOM节点，不会导致页面全部重绘
3.innerHTML 创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂
4.createElement() 创建多个元素效率稍低一点点，但是结构更清晰
总结：不同浏览器下，innerHTML效率要比createElement高

---------------------------------------------
注册事件概述
注册事件有两种方式：传统方式和方法监听注册方式

传统注册方式
    利用on开头的事件onclick
    特点:注册事件的唯一性
    同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数会覆盖前面注册的处理函数

-----------------------
方法监听注册方式
addEventListener()
    IE9之前不支持，使用attachEvent()代替
    特点:同一个元素同一个事件可以注册多个监听器
    按注册顺序依次执行

eventTarget.addEventListener(type, listener[, useCapture])
    type:事件类型字符串, 比如click, mouseover, 注意这里不要带on
    listener:事件处理函数，事件发生时，会调用该监听函数
    useCapture:可选参数，默认false

eventTarget.attachEvent(eventNameWithOn, callback)
    eventNameWithOn:事件类型字符串，比如onclick、onmouseover，这里要带on
    callback:事件处理函数
    ie9以前的版本支持，ie9以后以及别的浏览器都不支持

<button class="tradition">传统方式</button>
<button class="listener">注册监听方式</button>
<script>
    let traditionBtn = document.querySelector(".tradition");
    traditionBtn.onclick = () => {
        console.log("先注册的事件");
    }
    traditionBtn.onclick = () => {
        console.log("后注册的事件");
    }
    let listenerBtn = document.querySelector(".listener");
    listenerBtn.addEventListener("click", () => {
        console.log("先注册的事件");
    });
    listenerBtn.addEventListener("click", () => {
        console.log("后注册的事件");
    });
    listenerBtn.attachEvent('onclick', () => {
        console.log("attachEvent注册的事件");
    });
</script>

-----------------------
删除事件的方式

1.传统注册方式
eventTarget.onclick = null

2.方法监听注册方式
eventTarget.removeEventListener(type, listener[, useCapture])

3.ie9兼容 attachEvent
eventTarget.detachEvent(eventNamewithOn, callback)

<button class="listener">注册监听方式</button>
<script>
    let listenerBtn = document.querySelector(".listener");
    let cb = () => {
        console.log("先注册的事件");
    }
    listenerBtn.addEventListener("click", cb);
    listenerBtn.addEventListener("click", cb);//重复注册同一个事件的同一个回调只会生效一次
    listenerBtn.removeEventListener("click", cb);
    // listenerBtn.removeEventListener("click", cb);
</script>

---------------------------------------------
DOM事件流
事件流描述的是从页面中接受事件的顺序
事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程既是DOM事件流

DOM事件流分为3个阶段：
1.捕获阶段
2.当前目标阶段
3.冒泡阶段

事件冒泡：IE最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程
事件捕获：网景最早提出，由DOM最顶层节点开始，然后逐级向下传播到最具体的元素接收的过程

注意:
1.JS代码中只能执行捕获或者冒泡其中一个阶段
2.onclick 和 attachEvent 只能得到冒泡阶段
3.addEventListener()第三个参数如果是true，表示在事件捕获阶段调用事件处理程序
    如果是false(默认false)，表示在事件冒泡阶段调用事件处理程序
4.实际开发中很少使用事件捕获，更关注事件冒泡
5.有些事件是没有冒泡的，比如onblur、onfocus、onmouseenter、onmouseleave



-----------------------

---------------------------------------------

-----------------------

---------------------------------------------

-----------------------

---------------------------------------------

-----------------------

---------------------------------------------

-----------------------

---------------------------------------------

-----------------------

---------------------------------------------

-----------------------

---------------------------------------------

-----------------------

---------------------------------------------

-----------------------

---------------------------------------------

-----------------------

---------------------------------------------

-----------------------

---------------------------------------------

-----------------------

---------------------------------------------

-----------------------

---------------------------------------------

-----------------------