
---------------------------------------------
浏览器现状
国内的手机浏览器都是根据webkit修改过来的内核
兼容移动端主流浏览器，处理webkit内核浏览器即可

---------------------------------------------
视口
视口(viewport)就是浏览器显示页面内容的屏幕区域。
视口可以分为布局视口、视觉视口和理想视口

-----------------------
布局视口 layout viewport
一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期的pc端页面在手机上显示的问题
ios，android基本都将这个视口分辨率设为980px，所以pc上页面大多都能在手机上呈现，只
不过元素看上去很小，一般默认可以通过手动缩放页面。

-----------------------
视觉视口 visual viewport
用户正在看到的网站的区域
我们可以通过缩放去操作视觉视口，但不会影响布局视口，布局视口仍保持原来的宽度

-----------------------
理想视口 ideal viewport
为了使网站在移动端有最理想的浏览和阅读宽度而设定
理想视口，对设备来讲，是最理想的视扣尺寸
需要手动添加meta视口标签通知浏览器操作
meta视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有
多宽，布局的视口就多宽

-----------------------
meta视口标签
<meta name="viewport" content="width=device-width, user-scalable=no,
initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">

width:宽度设置的是viewport宽度，可以设置device-width特殊值
initial-scale:初始缩放比，大于0的数字
maximum-scale:最大缩放比，大于0的数字
minimum-scale:最小缩放比，大于0的数字
user-scalable:用户是否可以缩放, yes或no(1或0)

---------------------------------------------
物理像素&物理像素比
物理像素值指的是屏幕显示的最小颗粒，是物理真实存在的
一个px能显示的物理像素点的个数，称为物理像素比或屏幕像素比

---------------------------------------------
多倍图
对于一张50px*50px的图片，在手机retina屏幕中打开，按照物理像素比，会放大显示，图片模糊
所以用多倍图来解决模糊问题

-----------------------
背景缩放 background-size
background-size属性规定背景图片的尺寸
<style>
    div {
        /* 会拉伸到指定尺寸 */
        background-size: 背景图片宽度 背景图片高度;
        /* 会拉伸到指定尺寸，只指定宽度后，高度会按宽高比缩放 */
        background-size: 背景图片宽度;
        /* 里面的单位可以跟% 是相对于父盒子来说的 */
        background-size: 50%;
        /* cover 要完全覆盖div盒子 可能有部分背景图片显示不全
            是按照宽和高中比较短的那一侧来缩放到整个宽高 */
        background-size: cover;
        /* 按照宽和高中比较长的那一侧来缩放，当有一侧到达宽高之后停止拉伸
        可能有部分区域空白 */
        background-size: contain;
    }
</style>

---------------------------------------------
移动端浏览器
移动端浏览器基本以webkt内核为主，因此我们就考虑webkit兼容性问题
我们可以放心使用h5标签和css3样式
同时浏览器的私有前缀我们只需要考虑添加webkit即可

-----------------------
CSS初始化 normalize.css
移动端css初始化推荐使用 normalize.css/
    Normalize.css:保护了有价值的默认值
    Normalize.css:修复了浏览器的bug
    Normalize.css:是模块化的
    Normalize.css:拥有详细的文档

-----------------------
CSS3盒子模型 box-sizing
传统模式宽度计算: 盒子宽度 = CSS中设置的with + border + padding
CSS3盒子模型: 盒子的宽度 = CSS中设置的宽度width 里边包含了 border 和 padding
也就是说CSS3中的盒子模型，padding和border不会撑大盒子
<style>
    div {
        /* 传统盒子模型 */
        box-sizing: content-box;
        /* css3盒子模型 */
        box-sizing: border-box;
    }
</style>

移动端可以全部CSS3盒子模型
PC端如果完全需要兼容，就用传统模式，如果不考虑兼容性，就选择CSS3盒子模型

-----------------------
特殊样式
<style>
    div {
        /* CSS3盒子模型 */
        box-sizing: border-box;
        -webkit-box-sizing: border-box;

        /* 点击高亮需要清除 设置为transparent 透明 */
        -webkit-tap-highlight-color: transparent;

        /* 在移动浏览器默认的外观在ios上加上这个属性才能给按钮和输入框自定义样式 */
        -webkit-appearance: none;
        
    }        
    /* 禁用长按页面时的弹出菜单 */
    img, a {
        -webkit-touch-callout: none;
    }
</style>

---------------------------------------------
流式布局(百分比布局)
流式布局，就是百分比布局，也称非固定像素布局
通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充
流式布局方式是移动web开发常用的布局方式

<style>
    div {
        /* 最大宽度（高度） */
        max-width: XXpx;
        max-height: XXpx;
        /* 最小宽度（高度） */
        min-width: XXpx;
        min-height: XXpx;
    }
</style>

---------------------------------------------




-----------------------
移动端常用初始化样式

<style>
    body {
        margin: 0 auto;
        min-width: 320px;
        max-width: 640px;
        background: #fff;
        font-size: 14px;
        font-family: -apple-system, Helvetica, sans-serif;
        line-height: 1.5;
        color: #666;
    }
</style>

---------------------------------------------
flex弹性布局
操作方便，布局极为简单，移动端应用很广泛
PC端浏览器支持情况较差
IE11或更低版本，不支持或仅部分支持

-----------------------
布局原理
flex是flexible box的缩写，意为"弹性布局",用来为盒状模型提供最大的
灵活性，任何一个容器都可以指定为flex布局
flex布局原理
采用Flex布局的元素，称为Flex容器(flex布局原理 container),简称"容器"
它的所有子元素自动称为容器成员，称为Flex项目(flex item)，简称"项目"

通过给父盒子添加flex属性，来控制子盒子的位置和排列方式

当我们为父盒子设为flex布局后，子元素的float、clear和vertical-align属性将失效
伸缩布局 = 弹性布局 = 伸缩盒布局 = 弹性盒布局 = flex布局

-----------------------
常见父项属性
以下6个属性是对父元素设置的
<style>
    div {
        flex-direction: 设置主轴的方向;
        justify-content: 设置主轴上的子元素排列方式;
        flex-wrap: 设置子元素是否换行;
        align-content: 设置侧轴上的子元素的排列方式(多行);
        align-items: 设置侧轴上的子元素排列方式(单行);
        flex-flow: 复合属性，相当于同时设置了flex-direction 和 flex-wrap;
    }
</style>

-----------------------
flex-direction 设置主轴的方向
1.主轴和侧轴
在flex布局中，是分为主轴和侧轴两个方向，同样的叫法有: 行和列，x轴和y轴
默认主轴方向x轴方向，默认侧轴方向是y轴方向

2.属性值
flex-direction属性决定主轴方向(项目的排列方向)
flex-direction设置谁为主轴，剩下的就是侧轴，子元素是跟着主轴来排列的

<style>
    div {
        /* 默认值 从左到右 */
        flex-direction: row;
        /* 从右到左 */
        flex-direction: row-reverse;
        /* 从上到下 */
        flex-direction: column;
        /* 从下到上 */
        flex-direction: column-reverse;
    }
</style>

例子
<style>
    .box1 {
        width: 500px;
        height: 500px;
        display: flex;/* 给父级添加flex属性*/
        background-color: pink;
        flex-direction: column-reverse;
    }
    .box1 span {
        width: 100px;
        height: 100px;
        background-color: hotpink;
    }
</style>
<div class="box1">
    <span>1</span>
    <span>2</span>
    <span>3</span>
</div>

-----------------------
justify-content 设置主轴上的子元素排列方式
justify-content属性定义了项目在主轴上的对齐方式
使用这个属性之前一定要确定好主轴是哪个
<style>
    div {
        /* 默认值 从头部开始 如果主轴是x轴，则从左到右 都挤在左边*/
        justify-content: flex-start;
        /* 从尾部开始排列 都挤在右边*/
        justify-content: flex-end;
        /* center 在主轴居中对齐(如果主轴是x轴 则水平居中) 都挤在中间*/
        justify-content: center;
        /* 平分剩余空间 n等分*/
        justify-content: space-around;
        /* 先两边贴边 再平分剩余空间 */
        justify-content: space-between;
    }
</style>

-----------------------
flex-wrap 设置子元素是否换行
默认情况下，项目都排在一条线上，flex-wrap属性定义，flex布局中默认是不换行的
如果装不开，会缩小子元素的宽度，放到父元素里面
<style>
    div {
        /* 默认值 不换行 */
        flex-wrap: nowrap;
        /* 放不下就换行 */
        flex-wrap: wrap;
    }
</style>
-----------------------
align-items 设置侧轴上的子元素排列方式(单行)
该属性是控制子项在侧轴(默认是y轴)上的排列方式 在子项为单项的时候使用
<style>
    div {
        /* 默认值 从上到下 */
        align-items: flex-start;
        /* 从下到上 */
        align-items: flex-end;
        /* 挤在一起居中(垂直居中) */
        align-items: center;
        /* 拉伸 */
        align-items: stretch;
    }
</style>






-----------------------


---------------------------------------------


-----------------------

-----------------------

-----------------------
---------------------------------------------


-----------------------

-----------------------

-----------------------

---------------------------------------------


---------------------------------------------


-----------------------

-----------------------

-----------------------